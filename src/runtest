#!/bin/sh

FILE="$1"
test="${FILE%.*}"
ext="${FILE##*.}"

case $ext in
    ctst) log=clog; out=cout; ref=cref; ;;
    *)    log=log;  out=out; ref=ref; ;;
esac

case $CC in
    *-D_MPI=*) test -z "$EXEC" && EXEC="mpirun -np "`echo $CC | sed 's/.*-D_MPI=\([0-9]*\).*/\1/'`;
esac

for opt in $CFLAGS; do
    case $opt in
	-catch) test -z "$EXEC" && EXEC=" "; # turn off gdb
    esac
done

case $OSTYPE in
    *darwin*) ;;
    *)
	if test -z "$GDB"; then
	    GDB=`which gdb`
	fi
	;;
esac

script()
{
    rm -f $test.c
    if test -f fail; then
	return 1
    fi
    cat warn
    test -s warn || rm -f warn

    pass=true
    rm -f log-* stencil stencil-* fine fine-* coarse coarse-*
   if test -n "$EXEC" -o -z "$GDB"; then
	if ! $EXEC ./$test 2> $log > $out; then
	    pass=false
	    if test "$EXEC" = " " -a -f core -a -n "$GDB"; then
		cat $log
		xterm -e "gnuplot plot -" &
		$GDB -q ./$test core
	    fi
	fi
   else
	if ! $GDB -batch -return-child-result -ex "run 2> $log > $out" ./$test > gdb.log 2> gdb.err; then
	    pass=false
	    awk '
     {
       if (NF > 0)
         a[nb++] = $0;
     }
     / at .*:[0-9]*$/ {
       for (i = 0; i < nb - 1; i++)
	 print $(NF) ":error: " a[i];
     }
     ' < gdb.log >> $log
	fi
	rm -f gdb.log
    fi

    if test -f log-1; then
	mv -f $log log-0
	cat log-* > $log
    fi
    
    if $pass; then
	if test -f $test.$ref; then
	    ref=$ref
	else
	    ref=ref
	fi
	if test -f $test.$ref; then
            echo diff $log $test.$ref > fail
            diff $log $test.$ref >> fail && rm -f fail
            rm -f $test.$ref
	fi
    else
	cp -f $log fail
    fi
    if test -f fail; then
	return 1
    fi
    touch pass
}

# run locally
locally()
{
    echo \[$test.$ext\]
    $BASILISK/qcc -autolink $CFLAGS -o $test/$test $test.c $LIBS -lm > $test/warn 2>&1 \
	|| mv -f $test/warn $test/fail
    cd $test
    script
    cd ..
}

# run untrusted code using the 'basilisk-untrusted' user if it exists
run_untrusted()
{
    status=0
    if test -n "$chksum"; then
	if grep -q basilisk-untrusted /etc/passwd; then
	    if ! mkdir -m 777 ../$chksum; then
		return 1
	    fi
	    if ! sudo -n -u basilisk-untrusted -- \
		 bash -c "cp -arf * ../$chksum && cd ../$chksum && $1"; then
		status=1
	    fi
	    if ! cp -arf ../$chksum/* .; then
		status=1
	    fi
	    sudo -n -u basilisk-untrusted -- rm -rf ../$chksum/*
	    rm -r -f ../$chksum
	else
	    echo "Could not find the 'basilisk-untrusted' user" >2
	    status=1
	fi
    fi
    return $status
}

doplots()
{
    if ! run_untrusted "PNG=$PNG sh $BASILISK/gnuplot.sh $1 > tmp 2>&1"; then
	cat tmp >> warn
    fi
    if ! run_untrusted "MPLBACKEND=Agg python plots.py > tmp 2>&1"; then
	cat tmp >> warn
    fi
    rm -f tmp
}

# compile/run on a remote "sandbox"
remotely()
{
    rhost=$1
    autolink=`$BASILISK/qcc -autolink -progress -source $CFLAGS $test.c`
    chksum=`(cat $test.s && pwd && echo $test) | $GENSUM | cut -d' ' -f1`.$ext
    mkdir $test/$chksum
    cd $test
    cp -f $test.* $chksum 2> /dev/null || true
    rm -f $chksum/$test.c.page $chksum/$test.c.html
    if test `echo "$test" | sed 's/^~//'` != "$test"; then
	cd $chksum
	for f in "$test".*; do
	    mv -f "$f" `echo "$f" | sed 's/^~//'`
	done
	cd ..
    fi
    mv -f ../_$test.c $chksum/$test.c
    PCC="\$CC99"
    case "$CFLAGS" in
	*-cadna*) PCC="\$CADNACC" ;;
    esac
    PCFLAGS=`echo $CFLAGS | sed -e 's/-grid=[^-]*//' -e 's/-cadna//'`
    NCORES=`echo $EXEC | awk 'BEGIN{ np = 1 }{
      if ($1 == "mpirun") np = $3; }END{ print np;}'`
    cat <<EOF >$chksum/$chksum.sh
#!/bin/sh

run_untrusted()
{
  status=0
  notrust=/tmp/$chksum
  if ! sudo -n -u basilisk-untrusted -- bash -c "source \$HOME/.bashrc && mkdir \$notrust && cp -arf * \$notrust && cd \$notrust && rm -f complete && \$1 && touch complete"; then
     status=1
  fi
  if ! cp -arf \$notrust/* .; then
     status=1
  fi
  sudo -n -u basilisk-untrusted -- rm -rf \$notrust/
  return \$status
}

$PCC $PCFLAGS -I\$HOME/include -o $chksum $test.c -L\$HOME/lib $LIBS $autolink -lm > warn 2>&1 || mv -f warn fail
rm -f $test.c
if ! test -f fail; then
  test -s warn || rm -f warn

  pass=true
  if test -n "$EXEC" -o -z "`which gdb`"; then
    if ! run_untrusted "timeout 1h $EXEC ./$chksum 2> $log > $out"; then
       pass=false
    fi
  else
    if ! run_untrusted "timeout 1h gdb -batch -return-child-result -ex \"run 2> $log > $out\" $chksum > gdb.log 2> gdb.err" > gdb.log 2> gdb.err; then
       pass=false
       cat gdb.err >> $log
       awk '
       {
         if (NF > 0)
           a[nb++] = \$0;
       }
       / at .*:[0-9]*\$/ {
         for (i = 0; i < nb - 1; i++)
   	   print \$(NF) ":error: " a[i];
       }
       ' < gdb.log >> $log
    fi
    rm -f gdb.log
  fi    

  if test -f log-1; then
      mv -f $log log-0
      cat log-* > $log
  fi

  if \$pass; then
    if test -f $test.$ref; then
      ref=$ref
    else
      ref=ref
    fi
    if test -f $test.\$ref; then
        echo diff $log $test.\$ref > fail
        diff $log $test.\$ref >> fail && rm -f fail
        rm -f $test.\$ref
    fi
  else
    if ! test -s $log; then
       echo "The code timed out after one hour." > $log
    fi
    cp -f $log fail
  fi
  if ! test -f fail; then
    touch pass
  fi
fi
rm -f $chksum $test.c $chksum.sh $test.*ref
tar czf \$HOME/$chksum.tgz *
rm -r -f \$HOME/$chksum
EOF
    tar czf $chksum.tgz $chksum
    rm -r -f $chksum/

    if ! ( scp $chksum.tgz $rhost: && rm -f $chksum.tgz && \
	       ssh $rhost bash -c "\"tar xmzf $chksum.tgz && cd $chksum && tsp -N \$(test \$(tsp -S) -le $NCORES && echo \$(tsp -S) || echo $NCORES) -n nice -19 sh $chksum.sh\" && sleep 0 && echo $chksum && tsp -w" > tspid.$ext && \
	       scp -q $rhost:$chksum.tgz $chksum.tgz && \
	       ssh $rhost rm -r -f $chksum.tgz && \
	       tar xmzf $chksum.tgz && \
	       rm -f $chksum.tgz $test.c $test.*ref progress complete) > /dev/null 2>> ssh.log;
    then
	cat ssh.log >> fail
    fi
    rm -f ssh.log

    if test -f fail; then
	mv -f ../$test.$ext fail.$ext
	echo
	echo \[$test.$ext\]
	cat fail
    fi
    # generate graphics
    # this is obsolete and a security risk
    # (
    # 	cd ..
    # 	if test -f $test.plot -o -f $test.plot.page; then
    # 	    if ! make $test/plot.png > $test/.tmp 2>&1; then
    # 		cat $test/.tmp >> $test/warn
    # 	    fi
    # 	fi
    # )
    doplots "$test"
    # Complete
    rm -f *pid.$ext
}

checksum()
{
    if grep $1 $2 | $CHECKSUM; then 
	return 0;
    else
	return 1;
    fi
}

# check sum for test.c
source_modified=false
if ! test -f $test.$ext || ! checksum $test.c $test.$ext; then
    source_modified=true
fi

killchildren()
{
    p=$1
    c=`ps -o pid= --ppid $p`
    kill $p
    while test -n "$c"; do
	p=$c
	c=`ps -o pid= --ppid $p`
	kill $p
    done
}

# check sum for test.s
if test -f $test.$ext && checksum $test.s $test.$ext; then
    touch $test.$ext
    echo "make: '$test.$ext' is up to date."
    if $source_modified; then
	if test -n "$SANDBOX"; then
	    rm -f $test/warn
	    awk -f $BASILISK/gnuplot.awk < $test.c > $test/plots
	    awk -f $BASILISK/python.awk < $test.c > $test/plots.py
	    chksum=`(cat $test.s && pwd && echo $test) | $GENSUM | cut -d' ' -f1`.$ext
	    cd $test
	    doplots "$test"
	    cd ..
	fi
	$GENSUM $test.c $test.s > $test.$ext
    fi
# check sum for test.s in fail.tst
elif ! test -f $test/fail.$ext || ! checksum $test.s $test/fail.$ext; then
    if test -n "$SANDBOX" -a -f $test/pid.$ext; then
	killchildren `cat $test/pid.$ext`
	if test -f $test/tspid.$ext; then
	    ssh $SANDBOX killtest `cat $test/tspid.$ext`
	fi
	rm -f $test/*pid.$ext
    fi

    rm -f $test.$ext $test/pass \
	$test/fail $test/fail.* $test/warn $test/plot.png $test/plots $test/core
    $GENSUM $test.c $test.s > $test.$ext

    mkdir -p $test && cp -f $test.c $test
    awk -f $BASILISK/gnuplot.awk < $test.c > $test/plots
    awk -f $BASILISK/python.awk < $test.c > $test/plots.py
    cp -f $test.* $test 2> /dev/null || true
    rm -f $test/*.[sd] $test/*.*tst $test/$test.c.page 2> /dev/null || true

    if test -n "$SANDBOX"; then
        ( remotely $SANDBOX ) &
	echo $! > $test/pid.$ext
	sleep 1
    else
	locally
	rm -f $test/plots
    fi
fi

if test -f $test/fail; then
    cat $test/fail
    if test -f $test.$ext; then
	if test -n "$SANDBOX"; then
	    mv -f $test.$ext $test/fail.tst
	else
	    rm -f $test.$ext $test/fail.tst
	fi
    fi
    exit 1
elif test -f $test/pid.$ext; then
    echo \[$test.$ext on $SANDBOX \(`cat $test/pid.$ext`\)\]
    echo "  running..."
fi
