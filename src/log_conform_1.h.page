/**
# The log-conformation method for some constitutive models

## Introduction

The numerical resolution of viscoelastic fluid problems often face the
<a
href="http://www.ma.huji.ac.il/~razk/iWeb/My_Site/Research_files/Visco1.pdf">"The
High-Weissemberg Number Problem"</a>. This is a numerical instability
appearing when strongly elastic flows create regions of high stress
and fine features. This instability poses practical limits to the
values of the relaxation time of the viscoelastic fluid, $\lambda$.
Fattal \& Kupferman (2004, 2005) identified the exponential nature of
the solution as origin of the instability. Also,they proposed to
resort in the conformation tensor $\mathbf{A}$ (more precisely into
its logarithm, $\Psi = \log \, \mathbf{A}$) rather than in the
viscoelastic stress tensor to circumvent the instability.

## Equations

The constitutive equation for the log of the conformation tensor writes,

$$ 
D_t \Psi = rhs =  (\Omega \cdot \Psi -\Psi \cdot \Omega) + 2 \mathbf{B} +
\frac{e^{-\Psi} \mathbf{f}_R (e^{\Psi})}{\lambda}
$$

where $\Omega$ and $\mathbf{B}$ are tensors that result from the
decomposition of the tensor transverse of the gradient of the
velocity, 
$$ 
(\nabla \mathbf{u})^T = \Omega + \mathbf{B} + N
\mathbf{A}^{-1} 
$$ 
and $\mathbf{f}_R (\mathbf{A})$ is the relaxation
function that depends on the constituive model adopted.

The antisymmetric tensor $\Omega$ requires only the memory of a scalar
in 2D since,

$$ 
\Omega = \left( 
\begin{array}{cc}
0 & \Omega_{12} \\
-\Omega_{12} & 0
\end{array} 
\right)
$$

The log-conformation tensor, $\Psi$, is related to the viscoelastic
(polimeric) stress tensor $\mathbf{S}$, by the strain function $\mathbf{f}_S (\mathbf{A})$,

$$ 
\Psi = \log \, \mathbf{A} \quad \mbox{and} \quad \mathbf{S} =
\frac{\mu_p}{\lambda} \mathbf{f}_S (\mathbf{A})
$$

In Comminal et al. (2015) is gathered the functions $\mathbf{f}_S
(\mathbf{A})$ and $\mathbf{f}_S (\mathbf{A})$ for different
constitutive model. In the present library are implemented three
different (but related) constitutive models,
$$
\begin{array}{lcc}
\mbox{model} & \mathbf{f}_S (\mathbf{A}) & \mathbf{f}_R (\mathbf{A}) \\ 
\mbox{Oldroyd B} & \mathbf{A} -\mathbf{I} & \mathbf{A} -\mathbf{I} \\
\mbox{FENE P} & \frac{\mathbf{A}}{1-Tr(\mathbf{A})/L^2} -\mathbf{I} & \frac{\mathbf{A}}{1-Tr(\mathbf{A})/L^2} -\mathbf{I} \\
\mbox{FENE CR} & \frac{\mathbf{A}-\mathbf{I}}{1-Tr(\mathbf{A})/L^2}  & \frac{\mathbf{A}-\mathbf{I}}{1-Tr(\mathbf{A})/L^2}  \\ \\
\end{array}
$$
where $Tr$ denotes the Trace of the vector and $L$ is an additional
property of the viscoelastic fluid.

The divergence of $\mathbf{S}$ has to be added later to the momentum
equation as a source. Note that an oldroyd B viscoelastic fluid also
has a solvent part whose stresses follows a Newtonian behaviour. */

#include "bcg.h"
#define IMPLICIT 0

(const) scalar lambda = unity;
(const) scalar mup = unity;
(const) scalar trA = zeroc;

/**
## Variables

The main variable will be the stress tensor $\mathbf{S}$. Note that
$\Psi$ is not exactly the log-conformation tensor in the present
scheme. */

/**
The tensors below are symmetric but I do not get it to work it well! */

tensor S[]; //Stress tensor
tensor Psi[]; //Approx log of conformation tensor, Psi = log (A).
#if AXI
scalar Psiqq[], Sqq[];
#endif

/**
For other constitutive models than the Oldroyd B we use the
function below to set them. */

void (* f_s) (double, double *, double *);
void (* f_r) (double, double *, double *);

/** 
These structs resemble the Basilisk's vector and tensor but are just
arrays not related to the grid. */

typedef struct pseudo_v { double x, y;} pseudo_v;
typedef struct pseudo_t { struct pseudo_v x, y;} pseudo_t;

/**
The face vector below, *Soff*, serves to store the time integration of
the constituve equation at the faces. Using *Soff*, it is easy to
set boundary conditions for a non-slipping wall for the off diagonal
terms $S_{xy}$. */

#if 0
face vector Soff[]; // After some test I am almost sure this can be neglected
#endif

event defaults (i = 0) {
  if(is_constant(a.x))
    a = new face vector;
  if(f_s || f_r) 
    trA = new scalar;

  foreach() {
#if AXI
    Psiqq[] = Sqq[] = 0;
#endif

    foreach_dimension() {
      S.x.x[] = Psi.x.x[] = 0.;
      S.x.y[] = Psi.x.y[] = 0.;
    }
  }

  /**
  ## Boundary conditions

  By default we will set to zero Neumann boundary condition for all
  the components except if the bottom is an axis of symmetry.

  It would need further checking but I am pretty sure that, in
  practice, the boundary conditions for $\Psi$ are irrelevant and most
  of the content of the *defaults* event below would be safely
  dismissed.*/

  // BC for S
  vector v = S.x; //xx component
  v.t[top] = neumann (0.);
  v.t[bottom] = neumann (0.);
  v.n[left] = neumann (0.);
  v.n[right] = neumann (0.);

  v.n[top] = neumann (0.); //xy component
#if AXI
  v.n[bottom] = dirichlet (0.);
#else
  v.n[bottom] = neumann (0.);
#endif
  v.t[left] = neumann (0.);
  v.t[right] = neumann (0.);

  v = S.y; //yy component
  v.n[top] = neumann (0.);
  v.n[bottom] = neumann (0.);
  v.t[left] = neumann (0.);
  v.t[right] = neumann (0.);

  v.t[top] = neumann (0.); //yx component
#if AXI
  v.t[bottom] = dirichlet (0.);
#else
  v.t[bottom] = neumann (0.);
#endif
  v.n[left] = neumann (0.);
  v.n[right] = neumann (0.);


  // BC for Psi
  v = Psi.x;
  v.t[top] = neumann (0.); //xx component
  v.t[bottom] = neumann (0.);
  v.n[left] = neumann (0.);
  v.n[right] = neumann (0.);

  v.n[top] = neumann (0.); //xy component
  v.n[bottom] = neumann (0.);
  v.t[left] = neumann (0.);
  v.t[right] = neumann (0.);

  v = Psi.y; // yy component
  v.n[top] = neumann (0.);
  v.n[bottom] = neumann (0.);
  v.t[left] = neumann (0.);
  v.t[right] = neumann (0.);

  v.t[top] = neumann (0.); //yx component
  v.t[bottom] = neumann (0.);
  v.n[left] = neumann (0.);
  v.n[right] = neumann (0.);
}

event init (i = 0) {
#if AXI
  boundary((scalar *){S, Psi, Sqq, Psiqq});
#else
  boundary((scalar *){S, Psi});
#endif
}

/**
## Numerical Scheme 

The first step is to implement a routine to calculate the eigenvalues
and eigenvector of the conformation tensor $\mathbf{A}$. */

static void diagonalization_2D (double eval[dimension], 
				double evec[dimension][dimension],
				double A[dimension+1])
{
  /**
  The eigenvalues are saved in vector *eval* being computed from the
  trace and the determinant of the symmetric conformation tensor
  $\mathbf{A}$. The conformation tensor is stored in a vector of
  size 3 in 2D: $(A[0] = A_{11}, A[1] = A_{22}, A[2] = A_{12})$.*/

  if(sq(A[2]) < 1e-15) {
    evec[0][0] = evec[1][1] = 1.;
    evec[1][0] = evec[0][1] = 0.;
    eval[0] = A[0]; eval[1] = A[1];
  return;
  }

  double T = A[0] + A[1]; //Trace of tensor
  double D = A[0]*A[1] - sq(A[2]); //Determinant

  /**
  The eigenvectors, $\mathbf{v}_i$ are saved by columns in tensor
  $\mathbf{R} = (\mathbf{v}_1|\mathbf{v}_2)$.*/

  evec[0][0] = evec[0][1] = A[2];
  evec[1][0] = evec[1][1] = -A[0];
  double s = 1.;
  for (int i = 0; i < dimension; i++) { 
    eval[i] = T/2 + s*sqrt(sq(T)/4.-D);
    s *= -1;
    evec[1][i] += eval[i];
    double mod = sqrt(sq(evec[0][i])+sq(evec[1][i]));
    evec[0][i] /= mod;
    evec[1][i] /= mod;
  }
}

event tracer_advection (i++)
{
  double eigenval[2],  AC[3];
  double Ev[2][2];
  pseudo_t M;
#if IMPLICIT  
  scalar OM[];
#else
  double OM;
#endif
  pseudo_t B, A;
  symmetric tensor rhs[];
  double fa, eta, nu;
  scalar trac = trA;
#if AXI
  scalar * components = {Psi.x.x, Psi.x.y, Psi.y.y, Psiqq};
#else
  scalar * components = {Psi.x.x, Psi.x.y, Psi.y.y};
#endif

  /**
  The stress tensor depends on previous instants and it has to be
  integrated in time. In the log-conformation scheme the advance of
  the stress tensor is circumvented advancing in time the
  conformation, tensor, $\mathbf{A}$ (or more precisely its related
  variable $\Psi$).

  What follows we will adopt an scheme similar to that of Hao \& Pan
  (2007). They use an split scheme solving sucessively,

  a) the advection term:
$$ 
\partial_t \Psi + \nabla \cdot (\Psi \mathbf{u}) = 0
$$
  b) the upper convective term:
$$
\partial_t \Psi = 2 \mathbf{B} + (\Omega \cdot \Psi -\Psi \cdot \Omega)
$$
  c) the model term (but set in terms of the conformation 
  tensor $\mathbf{A}$). In a Oldroyd B viscoelastic fluid, the model is,   
$$ 
 \partial_t \mathbf{A} = -\frac{\mathbf{f}_R (\mathbf{A})}{\lambda}
$$

*Soff* serves to impose wall-type BC to the off-diagonal terms of the
stress tensor. */

#if 0  //See comment above
  foreach_face() {
    double lamf = (lambda[]+lambda[-1])/2;
    double str =  (mup[]+mup[-1])*(u.y[]-u.y[-1])/(2*Delta);
    Soff.x[] = (str*dt+lamf*Soff.x[])/(dt + lamf);
  }
#endif 

  foreach() {
    if (lambda[] != 0.) {
      eta = 1., nu = 1.;

      /**
      We assume that the stress tensor $\mathbf{S}$ depends on the
      conformation tensor $\mathbf{A}$ as follows,

      $$
      \mathbf{S} = \frac{\mu_p}{\lambda} f_s (\mathbf{A}) = \frac{\mu_p}{\lambda} \eta (\nu \mathbf{A} - I)  
      $$

      In most of the viscoelastic models,  $\nu$ and $\eta$ are 
      nonlinear parameters that depends on the trace of the conformation tensor,
      $\mathbf{A}$.*/

      if(f_s)
	f_s(trac[], &nu, &eta);

      double fa = (mup[] != 0 ? lambda[]/(mup[]*eta) : 0.);
     
      A.x.y = fa*S.x.y[]/nu;
      foreach_dimension()
	A.x.x = (fa*S.x.x[] + 1)/nu;

      /** 
      In the axisymmetric case, $\Psi_{\theta \theta} = \log A_{\theta
      \theta}$.  Therefore, $\Psi_{\theta \theta} = \log [ ( 1 + fa \, 
      S_{\theta \theta})/\nu] $. */

#if AXI
      double Aqq = (1 + fa*Sqq[])/nu;
      Psiqq[] = log (Aqq); 
#endif

      /** 
      The conformation tensor is diagonalized obtaining the
      eigenvector tensor $\mathbf{R}$ and the eigenvalues diagonal
      tensor, $\Lambda$ */
      
      AC[0] = A.x.x; AC[1] = A.y.y; AC[2] = A.x.y; 
      
      diagonalization_2D (eigenval, Ev, AC);
    
      pseudo_v eval = {eigenval[0], eigenval[1]};
      pseudo_t R = {{Ev[0][0], Ev[0][1]}, {Ev[1][0], Ev[1][1]}};
      
      /** 
      In the method it is also needed the tensor $\Psi = \log
      \mathbf{A}$ which is easily obtained after diagonalization, $\Psi
      = R \cdot \log(\Lambda) \cdot R^T$. */
      
      Psi.x.y[] = R.x.x*R.y.x*log(eval.x) + R.y.y*R.x.y*log(eval.y);    
      foreach_dimension()
	Psi.x.x[] = sq(R.x.x)*log(eval.x) + sq(R.x.y)*log(eval.y);

      /**
      The diagonalization will be applied to velocity gradient
      $(\nabla u)^T$ to obtain the antisymmetric tensor $\Omega$ and
      the traceless, symmetric tensor, $\mathbf{B}$. If the conformation
      tensor is $\mathbf{I}$, $\Omega = 0$ and $\mathbf{B}= \mathbf{D}$.  */
      
      if (eval.x-eval.y <= 1.e-20) {
#if IMPLICIT
	OM[] = 0;
#else
	OM = 0;
#endif
	B.x.y = (u.y[1,0]-u.y[-1,0] +
		 u.x[0,1]-u.x[0,-1])/(4.*Delta); 
	foreach_dimension() 
	  B.x.x = (u.x[1,0]-u.x[-1,0])/(2.*Delta);
      }
      else {
	foreach_dimension() {
	  M.x.x = (sq(R.x.x)*(u.x[1]-u.x[-1]) +
		   sq(R.y.x)*(u.y[0,1]-u.y[0,-1]) +
		   R.x.x*R.y.x*(u.x[0,1]-u.x[0,-1] + 
				u.y[1]-u.y[-1]))/(2.*Delta);
	  M.x.y = (R.x.x*R.x.y*(u.x[1]-u.x[-1]) + 
		   R.x.y*R.y.x*(u.y[1]-u.y[-1]) +
		   R.x.x*R.y.y*(u.x[0,1]-u.x[0,-1]) +
		   R.y.x*R.y.y*(u.y[0,1]-u.y[0,-1]))/(2.*Delta);
	}
	double omega = (eval.y*M.x.y + 
			eval.x*M.y.x)/(eval.y-eval.x);
#if IMPLICIT
	OM[] = (R.x.x*R.y.y-R.x.y*R.y.x)*omega;
#else
	OM = (R.x.x*R.y.y-R.x.y*R.y.x)*omega;
#endif
	
	B.x.y = M.x.x*R.x.x*R.y.x + M.y.y*R.y.y*R.x.y;
	foreach_dimension()
	  B.x.x = M.x.x*sq(R.x.x)+M.y.y*sq(R.x.y);	
      }

      /**
      Now we have all the elements to compute the right side of the
      advancing equation for $\Psi$. */

#if IMPLICIT    
      foreach_dimension()
	rhs.x.x[] = 2.*B.x.x*dt;
      rhs.x.y[] = 2.*B.x.y*dt;
#else
      double s = -Psi.x.y[];
      foreach_dimension() {
	s *= -1;
	rhs.x.x[] = 2*B.x.x + 2.*s*OM;
      }
      rhs.x.y[] = 2*B.x.y +OM*(Psi.y.y[]-Psi.x.x[]);
#endif
   }
  }
  
  /**
  We proceed with the step (a), the advection of the log of the
  conformation tensor $\Psi$, but first we apply boundary
  conditions. */

  boundary (components);
  advection (components, uf, dt);

  foreach() {
    if (lambda[] < 1e-6) {

      /** 
      If $\lambda = 0$ the stress tensor for the polymeric part
      reduces to the one of a Newtonian fluid $\mathbf{S} = 2 \mu_p
      \mathbf{D}$ being $\mathbf{D}$ the rate-of-strain
      tensor. Observe that $\mathbf{S}$ is in this case independent of
      time. */

      foreach_dimension()
	S.x.x[] = mup[]*(u.x[1,0]-u.x[-1,0])/Delta; // 2*mu*dxu;
      S.x.y[] = mup[]*(u.y[1,0]-u.y[-1,0] +
                       u.x[0,1]-u.x[0,-1])/(2.*Delta); // mu*(dxv+dyu)
      S.y.x[] = S.x.y[];  //Out if symmetric tensor works

      Psi.x.x[] = Psi.y.y[] = Psi.x.y[] = Psi.y.x[] = 0;
 #if AXI
      Psiqq[] = 0;
      Sqq[] = 2.*mup[]*u.y[]/y;
#endif
   }
    else {
      /**
      If $\lambda \neq 0$ we proceed with step (b). The upper
      convection of the log of the conformation tensor, $\Psi$. */

#if IMPLICIT
      foreach_dimension()
	rhs.x.x[] += Psi.x.x[];
      rhs.x.y[] += Psi.x.y[];

      Psi.x.x[] = (rhs.x.x[]+2.*dt*OM[]*rhs.x.y[] + 
		   2*sq(dt*OM[])*(rhs.x.x[]+rhs.y.y[]))/(1.+sq(2*dt*OM[]));
      Psi.y.y[] = (rhs.y.y[]-2.*dt*OM[]*rhs.x.y[] + 
		   2*sq(dt*OM[])*(rhs.x.x[]+rhs.y.y[]))/(1.+sq(2*dt*OM[]));
      Psi.x.y[] = (rhs.x.y[] + (rhs.y.y[]-rhs.x.x[])*dt*OM[])
	  /(1.+sq(2*dt*OM[]));
#else
      foreach_dimension()
        Psi.x.x[] += rhs.x.x[]*dt;
      Psi.x.y[] += rhs.x.y[]*dt;
#endif
      
      Psi.y.x[] = Psi.x.y[]; //Out if symmetric tensor works

      /**  
      In the axisymmetric case, the governing equation for $\Psi_{\theta
      \theta}$ only involves that component, 
       $$ 
       \Psi_{\theta \theta}|_t - 2 L_{\theta \theta} = 
       \frac{\mathbf{f}_R(e^{-\Psi_{\theta \theta}})}{\lambda} 
       $$
       being $L_{\theta \theta} = u_y/y$. Therefore step (b) for
       $\Psi_{\theta \theta}$ is, */

#if AXI
      Psiqq[] += dt*2.*u.y[]/y;
#endif
      
      /**
      It is time to undo the log-conformation, again by
      diagonalization, to recover the conformation tensor $\mathbf{A}$
      and to perform the step (c).*/

      AC[0] = Psi.x.x[]; AC[1] = Psi.y.y[]; AC[2] = Psi.x.y[]; 
      
      diagonalization_2D (eigenval, Ev, AC);
      
      pseudo_v eval = {exp(eigenval[0]),  exp(eigenval[1])};
      pseudo_t R = {{Ev[0][0], Ev[0][1]}, {Ev[1][0], Ev[1][1]}};
      
      A.x.y = R.x.x*R.y.x*eval.x + R.y.y*R.x.y*eval.y;
     foreach_dimension()
	A.x.x = sq(R.x.x)*eval.x + sq(R.x.y)*eval.y;
#if AXI
      double Aqq = exp(Psiqq[]);
#endif

      /**
      We perform now the step (c) by integrating 
      $\mathbf{A}_t = -\mathbf{f}_R (\mathbf{A})/\lambda$ to obtain
      $\mathbf{A}^{n+1}$. This step is analytic,

      $$
      \int_{t^n}^{t^{n+1}}\frac{d \mathbf{A}}{\mathbf{I}- \nu \mathbf{A}} = \frac{\eta \, \Delta t}{\lambda}
      $$

      */

      nu = 1; eta = 1.;
      if(f_r) {
#if 0 // Set to one if the midstep trace is to be used.
	double trac[] = A.x.x + A.y.y;
#if AXI
	trac[] += Aqq;
#endif
#endif
	f_r (trac[], &nu, &eta);
      }

      fa = exp(-nu*eta*dt/lambda[]);

#if AXI
      Aqq = (1-fa)/nu + fa*exp(Psiqq[]);
      Psiqq[] = log (Aqq);
#endif

      A.x.y = A.x.y*fa;
      foreach_dimension()
	A.x.x = (1-fa)/nu + A.x.x*fa;

      /**
      The trace in time $n+1$ is also needed in some models. */
      if(f_s || f_r) {
	trac[] = A.x.x + A.y.y;
#if AXI
	trac[] += Aqq;
#endif
      }


      /** 
      Then the stress tensor $\mathbf{S}^{n+1}$ is computed from
      $\mathbf{A}^{n+1}$ according to the constitutive model,
      $\mathbf{f}_S(\mathbf{A})$.  */

      nu = 1; eta = 1.;
      if(f_s)
	f_s (trac[], &nu, &eta);

      fa = mup[]/lambda[]*eta;
      
      S.x.y[] = fa*nu*A.x.y;
#if AXI
      Sqq[] = fa*(nu*Aqq - 1);
#endif
      foreach_dimension()
	S.x.x[] = fa*(nu*A.x.x - 1);

      S.y.x[] = S.x.y[];
    }
  }


#if AXI  
  boundary((scalar *){S, Psi, Psiqq, Sqq});
#else
  boundary((scalar *){S, Psi});
#endif
}

event acceleration (i++)
{

  face vector av = a;
  /**
  Tensor $\mathbf{S}$ is defined at cell centers while the corresponding 
  force (acceleration) will be defined at cell faces. To each component 
  of the momentum equation contributes two terms. For example for the 
  $x$-component in cartesian has the following terms: 
  $\partial_x \mathbf{S}_{xx} + \partial_y \mathbf{S}_{xy}$. The first term
  is easy to compute since can be calculated directly from center values
  of cells sharing the face. The other one is harder. It will be computed
  from vertex values. The vertex values are obtained averaging center ones.
  Note that as a result of the vertex averaging cells [] and [-1,0] are not
  involucrated in the computation of shear. */

  foreach_face() {
    double shear = (S.x.y[0,1]*cm[0,1]+S.x.y[-1,1]*cm[-1,1]-
	     S.x.y[0,-1]*cm[0,-1]-S.x.y[-1,-1]*cm[-1,-1])/4.;
    
    av.x[] += (fm.x[] <= 1.e-20 ? 0 :(shear+
				      cm[]*S.x.x[]-cm[-1]*S.x.x[-1])
               *alpha.x[]/(sq(fm.x[])*Delta));
  }
#if AXI
  foreach_face(y)
    av.y[] -= (y == 0. ? 0 : (Sqq[]+Sqq[0,-1])*alpha.y[]/sq(y)/2.);
#endif
}

/**
## Bibliography

 * R. Fattal and R. Kupferman. Constitutive laws for the matrix-logarithm of the conformation tensor. Journal of Non-Newtonian Fluid Mechanics. 2-3, pp. 281--285, (2004).

 * R. Fattal and R. Kupferman. Time-dependent simulation of viscoelastic flows at high Weissenberg number using the log-conformation representation. Journal of Non-Newtonian Fluid Mechanics. 1, pp. 23--27, (2005).

 * J. Hao and T-W. Pan. Simulation for high Weissenberg number. Applied Mathematics Letters. 20, 9. pp 988--993, (2007).

 * R. Comminal, J. Spangenberg and J.H. Hattel. Robust simulations of viscoelastic flows at high Weissenberg numbers with the streamfunction/log-conformation formulation. Journal of Non-Newtonian Fluid Mechanics, 223, pp.37--61, (2015).
*/
