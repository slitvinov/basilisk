/**
# Multilayer Saint-Venant system with mass exchanges

The multilayer Saint-Venant system is an extension of the classical
[Saint-Venant
system](http://en.wikipedia.org/wiki/Shallow_water_equations). It
consist in dividing the domain in horizontal layers and in solving the
Saint-Venant system in each layers. In this version of the method
there are also the friction between the layers and the mass transfer
in the vertical direction (see [1] for derivation). The equations we
solve are:

$$
\frac{\partial h}{\partial t} + \sum_{\alpha = 1}^{nl} 
\frac{\partial (l_{\alpha}hu_{\alpha})}{\partial x} = 0, 
$$

$$
\frac{\partial (l_{\alpha}hu_{\alpha})}{\partial t} + 
\frac{\partial}{\partial x} \left( l_{\alpha}hu_{\alpha}^{2} + 
\frac{g}{2}l_{\alpha}h^2 \right) = -gl_{\alpha}h\frac{\partial z_b}{\partial x} 
+ u_{\alpha+1/2}G_{\alpha+1/2}- u_{\alpha-1/2}G_{\alpha-1/2}
+ \frac{2\nu_{\alpha}}{l_{\alpha+1}+l_{\alpha}}\frac{u_{\alpha+1}
- u_{\alpha}}{h}-\frac{2\nu_{\alpha-1}}{l_{\alpha} + 
l_{\alpha-1}}\frac{u_{\alpha}-u_{\alpha-1}}{h}
$$

where $h$ is the total water depth, $l_{\alpha}$ the thickness of the
layer $\alpha$, $u_{\alpha}$ the mean velocity in the layer $\alpha$,
$z_b$ the topography term, $G_{\alpha+1/2}$ the mass transfer between
layers $\alpha$ and $\alpha+1$, $u_{\alpha+1/2}$ the velocity of the
interface between layers $\alpha$ and $\alpha + 1$, $\nu$ the
viscosity coefficient.

## Variables and parameters

The primary fields are the water depth *h*, the bathymetry *z~b~* and
$\eta$ the water level i.e. *z~b~ + h*. The variable *nl* is the
number of layer (default is 1), *layer* is a vector containing the
thickness of the layers (by default *layer = [1]*) and *ul* is the
vector list containing the velocity in each layer. The scalar list
*evolving* contains all the field that we advance in time which are
the velocities $u_{\alpha}$ and *h*. The structure of *evolving* is:
*evolving = {ul, h}* (see the default event).*/

scalar zb[], h[], eta[];
vector u, * ul = NULL;
int nl = 1;
double * layer;

/**
The physical parameters are the acceleration of gravity *G* and the
viscosity $\nu$ (zero by default). Cells are considered "dry" when the
water depth is less than the *dry* parameter. */

double G = 1.;
double nu = 0.;
double dry = 1e-10;

/**
## Time integration

Time integration will be done with a generic
[predictor-corrector](predictor-corrector.h) scheme. */

#include "predictor-corrector.h"

/**
The generic time-integration scheme in predictor-corrector.h needs
to know which fields are updated. */

scalar * evolving;

/**
We need to overload the default *advance* function of the
predictor-corrector scheme, because the evolving variables ($h$ and
$\mathbf{u}$) are not the conserved variables $h$ and
$h\mathbf{u}$. */

trace
static void advance_saint_venant (scalar * output, scalar * input, 
				  scalar * updates, double dt)
{
  // recover the scalar fields from the lists.
  scalar hi = input[dimension*nl], ho = output[dimension*nl],
    dh = updates[dimension*nl];

  // new fields in ho[], uo[]
  foreach() {
    double hold = hi[];
    ho[] = hold + dt*dh[];
    eta[] = zb[] + ho[];
    for (int l = 0; l < nl; l++) {
      double la = layer[l];
      vector ui = vector(input[dimension*l]), uo = vector(output[dimension*l]),
	dhu = vector(updates[dimension*l]);
      double hli = la*hold, hlo = la*ho[];
      if (ho[] > dry)  
	foreach_dimension() 
	  uo.x[] = (hli*ui.x[] + dt*dhu.x[])/hlo;     
      else 
	foreach_dimension() 
	  uo.x[] = 0.;
    }
  
    /**
    ## Vertical viscosity
  
    For the viscous step we need to solve a tridiagonal system. The
    vectors *a*, *b* and *c* contain the lower, principal and upper
    diagonals. */

    if (nl > 1 && nu != 0) {
      double a[nl], b[nl], c[nl], rhs[nl];

      assert (dimension == 1);
      
      /**
      The *rhs* of the tridiagonal system is $q_l = h_lu_l$. */
      
      int l = 0;
      for (scalar ul in output)
  	if (l < nl)
  	  rhs[l] = ho[]*layer[l]*ul[], l++;
      
      /**
      We compute all the coefficients. For the first layer we impose
      the *no-slip* condition. */
      
      a[0] = 0.;
      c[0] = - 2.*dt*nu/(ho[]*(layer[1] + layer[0]));
      b[0] = layer[0]*ho[] - c[0] + 2.*dt*nu/(ho[]*layer[0]);
      
#if 0 // Set to 1 if you want to use the Strickler coefficient for the bottom friction
      b[0] = 0.;
      double umean = 0.;   // mean vertical velocity
      double S = 25.;
      l = 0;
      for (scalar ul in output) {
	if (l<nl) 
	  umean += ul[]*layer[l++];
      }
      b[0] = layer[0]*ho[] - c[0] + dt*G*fabs(umean)/(S*S*pow(ho[],1./3.));
#endif
  
      // intermediate layers
      for (l = 1; l < nl-1; l++) {
  	a[l] = - 2.*dt*nu/(ho[]*(layer[l] + layer[l-1]));
  	c[l] = - 2.*dt*nu/(ho[]*(layer[l+1] + layer[l]));
  	b[l] = layer[l]*ho[] - a[l] - c[l];
      }
      
      // last layer
      a[nl-1] = - 2.*dt*nu/(ho[]*(layer[nl-2] + layer[nl-1]));
      c[nl-1] = 0.;
      b[nl-1] = layer[nl-1]*ho[] - a[nl-1];

      /**
      We can now solve the tridiagonal system using the [Thomas
      algorithm](https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm). */

      for (l = 1; l < nl; l++) {
  	b[l] -= a[l]*c[l-1]/b[l-1];
  	rhs[l] -= a[l]*rhs[l-1]/b[l-1];
      }
      a[nl-1] = rhs[nl-1]/b[nl-1];
      for (l = nl - 2; l >= 0; l--)
  	a[l] = (rhs[l] - c[l]*a[l+1])/b[l];
      
      /**
      Finally we update the list output with the new velocities and
      apply the boundary conditions. */
      
      l = 0;
      for (scalar ul in output)
  	if (l < nl)
  	  ul[] = a[l], l++;
    }
  }
  
  boundary ({eta});
  boundary (output);
}

/**
When using an adaptive discretisation (i.e. a tree)., we need
to make sure that $\eta$ is maintained as $z_b + h$ whenever cells are
refined or coarsened. */

#if TREE
static void refine_eta (Point point, scalar eta)
{
  foreach_child()
    eta[] = zb[] + h[];
}

static void coarsen_eta (Point point, scalar eta)
{
  eta[] = zb[] + h[];
}
#endif

/**
### Computing fluxes

Various approximate Riemann solvers are defined in [riemann.h](). */

#include "riemann.h"

trace
double update_saint_venant (scalar * evolving, scalar * updates, double dtmax)
{

  /**
  We first recover the currently evolving fields (as set by the
  predictor-corrector scheme). */

  scalar h = evolving[dimension*nl], dh = updates[dimension*nl];
  
  /**
  The gradients are stored in locally-allocated fields. First-order
  reconstruction is used for the gradient fields. */

  vector gh[], geta[];
  for (scalar s in {gh, geta}) {
    s.gradient = zero;
    #if TREE
      s.prolongation = refine_linear;
    #endif
  }
  gradients ({h, eta}, {gh, geta});
  
  /**
  *lFh* is the list of the flux of *h*, *lFq* is the list of the flux
  of *hu*, *lSb* is the list of the source term, *Se* is the list
  containing the net mass trasnfer. */

  scalar * lGa = NULL;

  // Allocate memory for fluxes

  for (int l = 0; l < nl; l++) {
    scalar Ga = new scalar;
    lGa = list_append (lGa, Ga);
  }

  foreach()
    dh[] = 0.;

  /**
  We go through each layer. */
  
  for (int l = 0; l < nl; l++) {

    /**
    We recover the velocity field for the current layer. */
    
    vector u = vector (evolving[dimension*l]);

    /**
    *Fh* and *Fq* will contain the fluxes for $h$ and $h\mathbf{u}$
    respectively and *S* is necessary to store the asymmetric topographic
    source term. */

    face vector Fh[], S[];
    tensor Fq[];

    /**
    The gradients are stored in locally-allocated fields. First-order
    reconstruction is used for the gradient fields. */
    
    tensor gu[];
#if 1
    // fixme: this is just so that the boundary conditions match the
    // older (incorrect) ones for the Higuera test case
    vector v = gu.x;
    v.n[left] = dirichlet(0);
    v.n[right] = dirichlet(0);
#endif    
    for (scalar s in {gu}) {
      s.gradient = zero;
      #if TREE
        s.prolongation = refine_linear;
      #endif
    }
    gradients ((scalar *) {u}, (vector *) {gu});

    /**
    The faces which are "wet" on at least one side are traversed. */
    
    foreach_face (reduction (min:dtmax)) {
      double hi = h[], hn = h[-1];
      if (hi > dry || hn > dry) {

	/**
	## Left/right state reconstruction
	
	The gradients computed above are used to reconstruct the left
	and right states of the primary fields $h$, $\mathbf{u}$,
	$z_b$. The "interface" topography $z_{lr}$ is reconstructed
	using the hydrostatic reconstruction of [Audusse et al,
	2004](/src/references.bib#audusse2004) */
	
        double dx = Delta/2.;
	double zi = eta[] - hi;
	double zl = zi - dx*(geta.x[] - gh.x[]);
	double zn = eta[-1] - hn;
	double zr = zn + dx*(geta.x[-1] - gh.x[-1]);
	double zlr = max(zl, zr);

	double hl = hi - dx*gh.x[];
	double up = u.x[] - dx*gu.x.x[];
	double hp = max(0., hl + zl - zlr);

	double hr = hn + dx*gh.x[-1];
	double um = u.x[-1] + dx*gu.x.x[-1];
	double hm = max(0., hr + zr - zlr);

	/**
	#### Riemann solver
	   
	We can now call one of the approximate Riemann solvers to get
	the fluxes. */

        double fh, fu, fv;
	kurganov (hm, hp, um, up, Delta*cm[]/fm.x[], &fh, &fu, &dtmax);
	fv = (fh > 0. ? u.y[-1] + dx*gu.y.x[-1] : u.y[] - dx*gu.y.x[])*fh;

	/**
	#### Topographic source term
	
	In the case of adaptive refinement, care must be taken to ensure
	well-balancing at coarse/fine faces (see [notes/balanced.tm]()). */

        #if TREE
	if (is_prolongation(cell)) {
	  hi = coarse(h,0);
	  zi = coarse(zb,0);
	}
	if (is_prolongation(neighbor(-1))) {
	  hn = coarse(h,-1);
	  zn = coarse(zb,-1);
	}
        #endif

	double sl = G/2.*(sq(hp) - sq(hl) + (hl + hi)*(zi - zl));
	double sr = G/2.*(sq(hm) - sq(hr) + (hr + hn)*(zn - zr));
	
	/**
	#### Flux update */
	
	Fh.x[]   = fm.x[]*fh;
	Fq.x.x[] = fm.x[]*(fu - sl);
	S.x[]    = fm.x[]*(fu - sr);
	Fq.y.x[] = fm.x[]*fv;
      }
      else // dry
	Fh.x[] = Fq.x.x[] = S.x[] = Fq.y.x[] = 0.;
    }

    boundary_flux ({Fh, S, Fq});
    
    vector dhu = vector(updates[dimension*l]);
    scalar Ga = lGa[l];
    foreach() {
      Ga[] = layer[l]*(Fh.x[1,0] - Fh.x[] + Fh.y[0,1] - Fh.y[])/(cm[]*Delta);
      dh[] -= Ga[];
      foreach_dimension()
        dhu.x[] = layer[l]*(Fq.x.x[] + Fq.x.y[] -
			    S.x[1,0] - Fq.x.y[0,1])/(cm[]*Delta);

      /**
      We also need to add the metric terms. They can be written (see
      eq. (8) of [Popinet, 2011](references.bib#popinet2011)) 
      $$
      S_g = h \left(\begin{array}{c}
      0\							\
      \frac{g}{2} h \partial_{\lambda} m_{\theta} + f_G u_y\	\
      \frac{g}{2} h \partial_{\theta} m_{\lambda} - f_G u_x
      \end{array}\right)
      $$
      with
      $$
      f_G = u_y \partial_{\lambda} m_{\theta} - u_x \partial_{\theta} m_{\lambda}
      $$
      */

      double dmdl = (fm.x[1,0] - fm.x[])/(cm[]*Delta);
      double dmdt = (fm.y[0,1] - fm.y[])/(cm[]*Delta);
      double fG = u.y[]*dmdl - u.x[]*dmdt;
      dhu.x[] += layer[l]*h[]*(G*h[]/2.*dmdl + fG*u.y[]);
      dhu.y[] += layer[l]*h[]*(G*h[]/2.*dmdt - fG*u.x[]);
    }
  }

  /**
  ## Vertical mass fluxes
     
  We now compute the mass exchanges term $G_{\alpha+1/2}$ and the
  interface velocity $u_{\alpha+1/2}$. We store the fluxes *fh* in
  the vector *Ga* and put the sum in *fH*. */

  if (nl > 1)
    foreach() {
      double Ga[nl];
      int l = 0;
      for (scalar g in lGa)
	Ga[l++] = g[];
    
      /**
      We store the velocity of the layers in the vector *ul*. */

      double ul[nl];
      l = 0;
      for (scalar v in evolving)
	if (l < nl)
	  ul[l++] = v[];

      /**
      Now we compute the term $G_{\alpha+1/2}$ (eq 2.22 of [1]):  
      $$ 
      G_{\alpha+1/2} = \sum_{j=1}^{\alpha} (\frac{\partial h_ju_j}{\partial x} - 
      l_j \sum_{p=1}^{nl}  \frac{\partial h_pu_p}{\partial x}) 
      $$  
      the interface velocity upwinding (eq. 2.23 of [1]) and store it in
      *uia* and then we combine this terms to get the term $Se_{\alpha}$
      that is the net mass flux in the layer $\alpha$:
      $$
      Se_{\alpha} = u_{\alpha+1/2}G_{\alpha+1/2} - u_{\alpha-1/2}G_{\alpha-1/2}
      $$ */
      
      assert (dimension == 1);
    
      double uia[nl], sea[nl];
      Ga[0] += layer[0]*dh[];
      if (Ga[0] >= 0.)
	uia[0] = ul[0];
      else
	uia[0] = ul[1];    
      sea[0] = Ga[0]*uia[0];
    
      for (int l = 1; l < nl-1; l++) {
	Ga[l] += Ga[l-1] + layer[l]*dh[];
	if (Ga[l] >= 0)
	  uia[l] = ul[l];
	else
	  uia[l] = ul[l+1];
	sea[l] = Ga[l]*uia[l] - Ga[l-1]*uia[l-1];
      }
      sea[nl-1] = - Ga[nl-2]*uia[nl-2];
    
      /**
      Finally, we add the exchange terms to the velocity updates. */

      for (int l = 0; l < nl; l++) {
	vector dhu = vector(updates[dimension*l]);
	dhu.x[] += sea[l];
      }
    }

  // Free memory
  delete (lGa);
  free (lGa);
  
  return dtmax;
}

/**
We free the memory. */

event cleanup (i = end) { 
  free (evolving);
  free (layer);
  free (ul);
}

/**
## Default and init event

Inside these events we create the *evolving* list, we overlad the
default *advance* and *update* function of the predictor-corrector
scheme. */

event defaults (i = 0)
{
  assert (ul == NULL);
  assert (nl > 0);
  for (int l = 0; l < nl; l++) {
    vector uu = new vector;
    ul = vectors_append (ul, uu);
  }
  u = ul[0];
  evolving = list_concat ((scalar *)ul, {h});
  
  /**
  All the layers have the same relative thickness. */

  layer = (double*) malloc(nl*sizeof(double));
  for (int l = 0; l < nl; l++)
    layer[l] = 1./nl;

  /**
  We overload the default 'advance' and 'update' functions of the
  predictor-corrector scheme and setup the refinement and coarsening
  methods on trees. */
  
  advance = advance_saint_venant;
  update = update_saint_venant;
#if TREE
  for (scalar s in {h,zb,u,eta}) { // fixme: also ul
    s.refine = s.prolongation = refine_linear;
    s.coarsen = coarsen_volume_average;
  }
  eta.refine  = refine_eta;
  eta.coarsen = coarsen_eta;
#endif
}

/**
The event below will happen after all the other initial events to take
into account user-defined field initialisations. */

event init (i = 0)
{
  foreach()
    eta[] = zb[] + h[];
  boundary (all);
}

#include "elevation.h"

/**
## Bibliography

* E. Audusse, F. M. Bristeau, B. Perthame and J. Saint-Marie, *A
Multilayer Saint-Venant System with mass excjanges for shallow water
flows. Derivation and Numerical Validation*, ESAIM: Mathematical
Modelling and Numerical Analysis, Vol 45, 169-200, 2011.
*/
